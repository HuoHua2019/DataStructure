# data structure learning_Day3

>  本人学习视频用的是青岛大学-王卓老师的，也在这里献上
>  视频链接：https://www.bilibili.com/video/BV1nJ411V7bd
>  数据结构与算法基础（青岛大学-王卓）


[TOC]

## 一、算法

### 1.算法的定义

- 对特定问题求解方法和步骤的一中描述，它是**指令**的有限**序列**。其中每个指令表示一个或多个操作。

  简而言之，算法就是**解决问题的方法和步骤**

<br>

### 2.算法的描述

- 自然语言：英文、中文等
- 流程图：传统流程图、NS流程图
- 伪代码：类语言-类C语言
- 程序代码：C语言、JAVA语言

<br>

### 3.算法与程序

- **算法**是解决问题的一种方法或一个过程，考虑如何将输入转换成输出，一个问题可以有多种算法

- **程序**时用某种程序设计语言对算法的具体实现

  ​	程序 = 数据结构 + 算法

  - 数据结构通过算法实现操作
  - 算法根据数据结构设计程序

<br>

### 4.算法特性

一个算法必须具备以下五个重要特性：

- 有穷性：一个算法必须总是在执行又穷步之后结束，且每一步都在又穷时间内完成
- 确定性：算法中的每一条指令必须有确定的含义，没有二义性，在任何条件下，只有唯一的一条执行路径，即对于相同的输入只能得到相容的输出
- 可行性：算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现
- 输入：一个算法有**零个**或**多个输入**
- 输出：一个算法有**一个**或**多个输出**

<br>

### 5.算法设计的要求

- 正确性（Correctness）

<img src="https://cdn.jsdelivr.net/gh/Huohua2019/Img/img/20201009211417.png" alt="msedge_cNdP3LqpC4" style="zoom: 67%;" />

- 可读性（Readability）

<img src="https://cdn.jsdelivr.net/gh/Huohua2019/Img/img/20201009211627.png" alt="msedge_5NEcK4PV7m" style="zoom:67%;" />

- 健壮性（Robustness）

<img src="https://cdn.jsdelivr.net/gh/Huohua2019/Img/img/20201009211725.png" alt="msedge_G6VgUmeL4P" style="zoom:80%;" />

- 高效性（Efficiency）

<img src="https://cdn.jsdelivr.net/gh/Huohua2019/Img/img/20201009211813.png" alt="msedge_3MVSrrZ99x" style="zoom:67%;" />

<br>

## 二、算法和算法分析

- 一个好的算法首先要具备正确性，然后是健壮性，可读性，在几个方面都满足的情况下，主要考虑**算法的效率**，通过算法的效率高低来评判不同算法的优劣程度

- 算法效率以两个方面来考虑：

  1. 时间效率：指的是算法所耗费的<u>时间</u>；
  2. 空间效率：指的是算法执行过程中所耗费的<u>存储空间</u>

  - 时间效率和空间效率有时候是矛盾的

<br>

### 1.算法时间效率的度量

- 算法时间效率可以用依据该算法编制的程序在计算机上执行**所消耗的时间**来度量
- 两种度量方法
  - 事后统计：
    - 将算法实现，测算其时间和空间开销
    - 缺点：编写程序实现算法将花费较多的时间和经历；所得实验结果依赖于计算机的软硬件等环境因素，掩盖算法本身的优劣
  - 事前分析：
    - 对算法所消耗资源的一种估算方法

<br>

### 2.事前分析方法

- 一个算法的运行时间是指一个算法在计算机上运行所耗费的时间大致可以等于计算机执行一种简单的操作（如赋值、比较、移动等）所需的**时间**与算法中进行的简单操作**次数**乘机

​	算法运行时间 = 一个简单操作所需的时间 x 简单操作次数

- 也即算法中每条语句的执行时间之和

  算法运行时间 = ∑每条语句的执行次数（又称为语句频度） x 该语句执行一次所需的时间

每条语句执行一次所需的时间，一般是随机器而异的。取决于机器的指令性能、速度以及编译的代码质量、是由机器本身软硬件环境决定的，它与算法无关。

所以我们课假设执行每条语句所需的时间均为单位时间。此时对算法的运行时间的讨论就可转化为讨论该算法中所有语句的执行次数，即频度之和。

这就可以独立于不同机器的软硬件环境来分析算法的时间性能了。

例如：两个n x n 矩阵相乘的算法课描述为：

```C
for (i = 1; i <= n; i++)                              //n+1次
    for (j = 1; j <= n; j++)                          //n(n+1)次
    {
        c[i][j] = 0;                                  //n*n次
        for (k = 0; k < n; k++)                       //n*n*(n+1)次
            c[i][j] = c[i][j] + a[i][k] * b[k][j];    //n*n*n次
    }
```

我们把算法所耗费的时间定义为该算法中每条语句的频度之和，则上述算法的时间消耗T(n)为：
$$
T(n)=2n^3+3n^2+2n+1
$$
<br>

### 3.算法时间复杂度的渐进表示法

- 为了便于比较不同算法的时间效率，我们仅比较它们的数量级

​	例如：两个不同的算法，时间消耗分别是：
$$
T_1(n)=10n^2 与 T_2(n)=5n^3
$$

- 若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为**不等于零的常数**，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n))为**算法的渐进时间复杂度**（*O是数量级的符号*）简称时间复杂度。

对于求解矩阵相乘问题，算法耗费时间：
$$
T(n)=2n^3+3n^2+2n+1,n\rightarrow\infty时，T(n)/n^3\rightarrow2，这表示n充分大时，T(n)与n^3是同阶或同数量级，引入大“O”记号，则T(n)可记作：T(n)=O(n^3)
$$
这就是求解矩阵相乘问题的算法的渐进时间复杂度

一般情况下，不必计算所有操作的执行次数，而只考虑算法中基本操作执行的次数，它是问题规模n的某个函数，用T(n)表示。

<br>

### 4.算法时间复杂度定义

算法中基本语句重复执行的次数是问题规模n的某个函数f(n)，算法的时间量度记作：T(n)=O(f(n))

它表示随着n的增大，算法执行的时间的增长率和f(n)的增长率相同，称**渐进时间复杂度**。

<img src="https://cdn.jsdelivr.net/gh/Huohua2019/Img/img/20201010165809.png" alt="msedge_FCJmCRHRA9" style="zoom:67%;" />

数学符号“O”的定义为：
$$
若T(n)和f(n)是定义在正整数集合上的两个函数，则T(n)=O(f(n))表示存在正的常数C和n_0，使得当n\geq n_0时都满足0\leq T(n)\leq Cf(n)。
$$

<br>

### 5.分析算法时间复杂度的基本方法

定理1.1
$$
若f(n)=a_mn^m+a_{m-1}n^{m-1}+...a_1n+a_0是m次多项式，则T(n)=O(n^m)
$$
忽略所有**低次幂项和最高次幂系数**，体现出增长率的含义

1. 找出**语句频度最大**的那条语句作为基本语句
2. 计算**基本语句**的频度得到问题规模n 的某个函数f(n)
3. 取其数量级用符号“O”表示

<img src="https://cdn.jsdelivr.net/gh/Huohua2019/Img/img/20201010213927.png" alt="msedge_dLLzSJ1lYj" style="zoom:67%;" />

<br>

### 6.算法时间复杂度分析例题

例1：

<img src="https://cdn.jsdelivr.net/gh/Huohua2019/Img/img/20201010214518.png" alt="msedge_uIHf008ih1" style="zoom: 80%;" />

例2：

<img src="https://cdn.jsdelivr.net/gh/Huohua2019/Img/img/20201010214740.jpg" alt="msedge_O4LUcTKHZE"  />
$$
\begin{align}
& =\frac{1}{2}(\sum_{i=1}^{n}i^2+\sum_{i=1}^{n}i)\\
& =\frac{1}{2}(\frac{n(n+1)(2n+1)}{6}+\frac{n(n+1)}{2})\\
& =\frac{n(n+1)(n+2)}{6}
\end{align}
$$

例3：

<img src="https://cdn.jsdelivr.net/gh/Huohua2019/Img/img/20201010223950.jpg" alt="msedge_sTt16sJrpY" style="zoom:80%;" />

<br>

### 7.算法时间复杂度计算

有的情况下，算法中基本操作重复执行的次数还随问题的**输入数据集**不同而不同

<img src="https://cdn.jsdelivr.net/gh/Huohua2019/Img/img/20201011160323.png" alt="msedge_dMHgCrmYZN" style="zoom:80%;" />

- 最坏时间复杂度：指在最坏情况下，算法的时间复杂度

- 平均时间复杂度：指在所有可能输入实例在等概率出现的情况下，算法的期望运行时间

- 最好时间复杂度：指在最好情况下，算法的时间复杂度

一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长

- 对于复杂的算法，可以将它分成几个容易估算的部分，然后利用大O加法法则和乘法法则，计算算法的时间复杂度：

  - 加法规则

  $$
  T(n)=T1(n)+T2(n)=O(g(n))=O(max(f(n),g(n)))
  $$
  - 乘法法则

  $$
  T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))
  $$

<br>

### 8.算法时间效率的比较

- 当n取得很大时，指数时间算法和多项式时间算法在所需时间上非常悬殊

<img src="https://cdn.jsdelivr.net/gh/Huohua2019/Img/img/20201011161914.png" alt="msedge_yshuxkzbZj" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/Huohua2019/Img/img/20201011162025.png" alt="msedge_e5yHGQqYsc" style="zoom: 80%;" />



![msedge_59dNpCdi9k](https://cdn.jsdelivr.net/gh/Huohua2019/Img/img/20201011162334.png)

<br>

### 9.渐进空间复杂度

- 空间复杂度：算法所需存储空间的度量，记作：s(n)=O(f(n)) 其中n为问题的规模（或大小）
- 算法要占据的空间
  - 算法本身要占据的空间，输入/输出，指令，常数，变量等
  - 算法要使用的辅助空间

<br>

### 10.算法空间复杂度分析例题

【例】将一位数组a中的n个数逆序存放到原数组中。

<img src="https://cdn.jsdelivr.net/gh/Huohua2019/Img/img/20201011162823.png" alt="msedge_Ri5R1m9qBz" style="zoom:67%;" />

对于算法1：s(n)=O(1)；对于算法2：S(n)=O(n)

<br>